<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Basic watermark removal in videos - Paul's blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Paul Willot"><meta name=description content="The general problem of completing images and videos depending on a mask is called inpainting, and numerous methods exists to tackle this problem in ingenuous ways.
However most approaches are relatively costly to run, especially without a graphic card, so I wanted to see what result we could get with simple and fast methods.
You can find the code for the steps below in this repository.
To start, we need to find the mask, which correspond to the location of pixels to remove."><meta name=keywords content="ML,CS"><meta name=generator content="Hugo 0.79.1 with theme even"><link rel=canonical href=/post/basic-watermark-removal-in-videos/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.d70ccb6824a5ce6b30b3758201981307a7fcc24b19562e15fbbdf20fcdf12f61.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Basic watermark removal in videos"><meta property="og:description" content="The general problem of completing images and videos depending on a mask is called inpainting, and numerous methods exists to tackle this problem in ingenuous ways.
However most approaches are relatively costly to run, especially without a graphic card, so I wanted to see what result we could get with simple and fast methods.
You can find the code for the steps below in this repository.
To start, we need to find the mask, which correspond to the location of pixels to remove."><meta property="og:type" content="article"><meta property="og:url" content="/post/basic-watermark-removal-in-videos/"><meta property="article:published_time" content="2021-04-13T06:30:26+00:00"><meta property="article:modified_time" content="2021-04-13T06:30:26+00:00"><meta itemprop=name content="Basic watermark removal in videos"><meta itemprop=description content="The general problem of completing images and videos depending on a mask is called inpainting, and numerous methods exists to tackle this problem in ingenuous ways.
However most approaches are relatively costly to run, especially without a graphic card, so I wanted to see what result we could get with simple and fast methods.
You can find the code for the steps below in this repository.
To start, we need to find the mask, which correspond to the location of pixels to remove."><meta itemprop=datePublished content="2021-04-13T06:30:26+00:00"><meta itemprop=dateModified content="2021-04-13T06:30:26+00:00"><meta itemprop=wordCount content="390"><meta itemprop=keywords content="video,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Basic watermark removal in videos"><meta name=twitter:description content="The general problem of completing images and videos depending on a mask is called inpainting, and numerous methods exists to tackle this problem in ingenuous ways.
However most approaches are relatively costly to run, especially without a graphic card, so I wanted to see what result we could get with simple and fast methods.
You can find the code for the steps below in this repository.
To start, we need to find the mask, which correspond to the location of pixels to remove."><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>paulw.tokyo</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>paulw.tokyo</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Basic watermark removal in videos</h1><div class=post-meta><span class=post-time>2021-04-13</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents></nav></div></div><div class=post-content><p>The general problem of completing images and videos depending on a mask is called <a href=https://en.wikipedia.org/wiki/Inpainting>inpainting</a>, and numerous methods exists to tackle this problem in <a href=https://dmitryulyanov.github.io/deep_image_prior title="deep image prior">ingenuous ways</a>.</p><p>However most approaches are relatively costly to run, especially without a graphic card, so I wanted to see what result we could get with simple and fast methods.</p><p>You can find the code for the steps below in <a href=https://github.com/m3at/video-watermark-removal title="github video-watermark-removal">this repository</a>.</p><p><img src=/uploads/watermark_removal.webp alt="Watermark removal on one frame" title="Example watermark removal"></p><p>To start, we need to find the mask, which correspond to the location of pixels to remove.</p><p>Using <a href=https://www.ffmpeg.org/ title="ffmpeg website">ffmpeg</a> we can extract the timestamps of the <a href=https://en.wikipedia.org/wiki/Key_frame title="key frame">key frames</a> in the video. Getting only the timing is fast, and we can later cap to a maximum the number of frames to actually extract. We could also take random frames, but the key frames are more likely to be diverse (can&rsquo;t be too close in time), and faster to extract as other frames need to be reconstructed from the closest key.</p><p>With ffmpeg, we just need to run:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>ffprobe -select_streams v -skip_frame nokey -show_frames -show_entries <span class=nv>frame</span><span class=o>=</span>pkt_pts_time video.mp4
</code></pre></td></tr></table></div></div><p>Then for each <code>TIMESTAMP</code> obtained, we can extract the frame:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>ffmpeg -ss TIMESTAMP -i video.mp4 -vframes <span class=m>1</span> frame.png
</code></pre></td></tr></table></div></div><p>And lastly we can aggregate the results of a simple image filter over all frames, to create a mask:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=c1># Compute the gradients per image</span>
<span class=n>dx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>gradient</span><span class=p>(</span><span class=n>images</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>axis</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=n>dy</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>gradient</span><span class=p>(</span><span class=n>images</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>axis</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>

<span class=c1># Average globally</span>
<span class=n>mean_dx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>dx</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>))</span>
<span class=n>mean_dy</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>dy</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>))</span>

<span class=c1># Filter on both axis at a hand picked threshold</span>
<span class=n>threshold</span> <span class=o>=</span> <span class=mi>10</span>
<span class=n>salient</span> <span class=o>=</span> <span class=p>((</span><span class=n>mean_dx</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=p>)</span> <span class=o>|</span> <span class=p>(</span><span class=n>mean_dy</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=p>))</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>float</span><span class=p>)</span>
<span class=n>salient</span> <span class=o>=</span> <span class=n>normalize</span><span class=p>(</span><span class=n>gaussian_filter</span><span class=p>(</span><span class=n>salient</span><span class=p>,</span> <span class=n>sigma</span><span class=o>=</span><span class=mi>3</span><span class=p>))</span>
<span class=n>mask</span> <span class=o>=</span> <span class=p>((</span><span class=n>salient</span> <span class=o>&gt;</span> <span class=mf>0.2</span><span class=p>)</span> <span class=o>*</span> <span class=mi>255</span><span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>uint8</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p><em>Bonus, if one wants to do it without python, it should be doable using ImageMagick&rsquo;s <code>convert</code> with the existing</em> <a href=https://legacy.imagemagick.org/Usage/convolve/#sobel title="Sobel ImageMagick"><em>Sobel filter</em></a> <em>and <code>-evaluate-sequence mean *.png mean.png</code>.</em></p><p>We now have a global mask to inpaint, so we can simply use ffmpeg&rsquo;s <a href=https://ffmpeg.org/ffmpeg-filters.html#removelogo><code>removelogo</code></a> filter to obtain our cleaned-up video:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>ffmpeg -i video.mp4 -vf <span class=s2>&#34;removelogo=mask.png&#34;</span> cleaned.mp4
</code></pre></td></tr></table></div></div><p>This run at around x3 real-time on my aging MacBook Pro (i5-5287U), with a fixed overhead of ~5s for the mask extraction, which is fast! ✨</p><p>Clearly the resulting inpainting is not of high quality –we&rsquo;re not even leveraging temporal information across frames– but is reasonable enough as a baseline to compare against real-time approaches.</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Paul Willot</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2021-04-13</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/video/>video</a></div><nav class=post-nav><a class=prev href=/post/denormal-number-at-inference-in-pytorch/><i class="iconfont icon-left"></i><span class="prev-text nav-default">Denormal number at inference in PyTorch</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/post/space-filling-curves-and-transformer/><span class="next-text nav-default">Space filling curves and CNN</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=https://www.linkedin.com/in/paul-willot-903a6b5b/ class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/m3at class="iconfont icon-github" title=github></a><a href=/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=copyright-year>&copy;
2020 -
2021
<span>Paul Willot</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.9c0479e84fa822bb8c96fb7d4d5db053030015bee7a6be51aa29f8f6fc1f3c41.js></script></body></html>